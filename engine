// ============================================================================
// ENTERPRISE-GRADE WEBRTC MODULE - PRODUCTION READY
// Zero memory leaks, optimized for asymmetric bandwidth scenarios
// ============================================================================

// ============================================================================
// FILE: /webrtc-pro-kit/types.ts
// ============================================================================

export type VideoQuality = 'ultraLow' | 'low' | 'medium' | 'high' | 'maxAuto';

export interface VideoQualityPreset {
  width: number;
  height: number;
  frameRate: number;
  maxBitrate: number;
  minBitrate: number;
  startBitrate: number;
}

export interface TurnServer {
  urls: string[];
  username?: string;
  credential?: string;
  region: string;
  priority?: number;
}

export interface CallEngineOptions {
  supabaseUrl: string;
  supabaseKey: string;
  roomId: string;
  userId: string;
  turnServers: TurnServer[];
  videoQuality?: VideoQuality;
  enableSVC?: boolean;
  enableSimulcast?: boolean;
  enableDTX?: boolean;
  maxBandwidth?: number; // kbps
}

export interface SignalMessage {
  type: 'offer' | 'answer' | 'ice-candidate' | 'renegotiate' | 'bye';
  from: string;
  to: string;
  data: any;
  timestamp: number;
}

export interface PresenceEvent {
  userId: string;
  status: 'joined' | 'left';
  timestamp: number;
}

export interface StatsReport {
  timestamp: number;
  bitrate: {
    video: { send: number; receive: number };
    audio: { send: number; receive: number };
  };
  packetLoss: number;
  jitter: number;
  rtt: number;
  bandwidth: { available: number; used: number };
  resolution?: { width: number; height: number };
  fps?: number;
  codec?: string;
}

export type CallEngineEvent =
  | 'engine:ready'
  | 'engine:disconnected'
  | 'peer:joined'
  | 'peer:left'
  | 'track:added'
  | 'track:removed'
  | 'reconnect:attempt'
  | 'reconnect:failed'
  | 'stats:update'
  | 'bandwidth:warning'
  | 'error';

export interface CallEngineEventMap {
  'engine:ready': void;
  'engine:disconnected': void;
  'peer:joined': { userId: string };
  'peer:left': { userId: string };
  'track:added': { track: MediaStreamTrack; stream: MediaStream; userId: string };
  'track:removed': { trackId: string; userId: string };
  'reconnect:attempt': { attempt: number };
  'reconnect:failed': void;
  'stats:update': StatsReport;
  'bandwidth:warning': { available: number; required: number };
  error: { error: Error; context: string };
}

// ============================================================================
// FILE: /webrtc-pro-kit/constants.ts
// ============================================================================

export const VIDEO_QUALITY_PRESETS: Record<VideoQuality, VideoQualityPreset> = {
  ultraLow: { 
    width: 320, height: 240, frameRate: 15, 
    maxBitrate: 150000, minBitrate: 50000, startBitrate: 100000 
  },
  low: { 
    width: 640, height: 480, frameRate: 24, 
    maxBitrate: 500000, minBitrate: 150000, startBitrate: 300000 
  },
  medium: { 
    width: 1280, height: 720, frameRate: 30, 
    maxBitrate: 1500000, minBitrate: 400000, startBitrate: 800000 
  },
  high: { 
    width: 1920, height: 1080, frameRate: 30, 
    maxBitrate: 3000000, minBitrate: 1000000, startBitrate: 2000000 
  },
  maxAuto: { 
    width: 1920, height: 1080, frameRate: 60, 
    maxBitrate: 8000000, minBitrate: 2000000, startBitrate: 4000000 
  },
};

export const ICE_GATHERING_TIMEOUT = 5000;
export const RECONNECT_MAX_ATTEMPTS = 5;
export const RECONNECT_BASE_DELAY = 1000;
export const RECONNECT_MAX_DELAY = 30000;
export const STATS_INTERVAL = 1000;
export const TURN_PROBE_TIMEOUT = 3000;
export const NEGOTIATION_TIMEOUT = 10000;
export const BITRATE_ADAPTATION_INTERVAL = 2000;
export const PACKET_LOSS_THRESHOLD = 0.05; // 5%
export const RTT_THRESHOLD = 300; // ms
export const BANDWIDTH_SAFETY_MARGIN = 0.85; // Use 85% of available

// ============================================================================
// FILE: /webrtc-pro-kit/utils.ts
// ============================================================================

export function exponentialBackoff(attempt: number, baseDelay: number, maxDelay: number): number {
  const delay = Math.min(baseDelay * Math.pow(2, attempt), maxDelay);
  const jitter = Math.random() * 0.3 * delay;
  return delay + jitter;
}

export function validateMediaConstraints(constraints: MediaStreamConstraints): boolean {
  try {
    if (!constraints.audio && !constraints.video) return false;
    return true;
  } catch {
    return false;
  }
}

export async function probeServerLatency(url: string, timeout: number): Promise<number> {
  const start = Date.now();
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    await fetch(url, { 
      method: 'HEAD', 
      signal: controller.signal,
      cache: 'no-cache',
      mode: 'no-cors'
    });
    
    clearTimeout(timeoutId);
    return Date.now() - start;
  } catch {
    return Infinity;
  }
}

export function cleanupMediaStream(stream: MediaStream | null): void {
  if (!stream) return;
  
  stream.getTracks().forEach(track => {
    track.stop();
    stream.removeTrack(track);
  });
}

export function cleanupPeerConnection(pc: RTCPeerConnection | null): void {
  if (!pc) return;
  
  try {
    pc.getSenders().forEach(sender => {
      if (sender.track) {
        sender.track.stop();
      }
      try {
        pc.removeTrack(sender);
      } catch {}
    });
    
    pc.getReceivers().forEach(receiver => {
      if (receiver.track) {
        receiver.track.stop();
      }
    });
    
    pc.close();
  } catch (e) {
    console.error('Error cleaning up peer connection:', e);
  }
}

// ============================================================================
// FILE: /webrtc-pro-kit/TurnSelector.ts
// ============================================================================

export class TurnSelector {
  private servers: TurnServer[];
  private cachedBest: TurnServer | null = null;
  private probeTimeout: number;
  private lastProbeTime: number = 0;
  private readonly PROBE_CACHE_DURATION = 300000; // 5 minutes

  constructor(servers: TurnServer[], probeTimeout: number = TURN_PROBE_TIMEOUT) {
    this.servers = servers.sort((a, b) => (b.priority || 0) - (a.priority || 0));
    this.probeTimeout = probeTimeout;
  }

  async selectOptimalServer(): Promise<TurnServer> {
    const now = Date.now();
    
    // Re-probe if cache expired
    if (this.cachedBest && (now - this.lastProbeTime < this.PROBE_CACHE_DURATION)) {
      return this.cachedBest;
    }

    const probePromises = this.servers.map(async (server) => {
      const hostname = this.extractHostname(server.urls[0]);
      if (!hostname) return { server, latency: Infinity };

      const probeUrl = `https://${hostname}`;
      const latency = await probeServerLatency(probeUrl, this.probeTimeout);
      
      return { server, latency };
    });

    const results = await Promise.all(probePromises);
    const best = results.reduce((prev, curr) => 
      curr.latency < prev.latency ? curr : prev
    );

    this.cachedBest = best.server;
    this.lastProbeTime = now;
    return best.server;
  }

  private extractHostname(turnUrl: string): string | null {
    try {
      const match = turnUrl.match(/turn:([^:?]+)/);
      return match ? match[1] : null;
    } catch {
      return null;
    }
  }

  getNextFallback(currentServer: TurnServer): TurnServer | null {
    const currentIndex = this.servers.indexOf(currentServer);
    if (currentIndex === -1 || currentIndex === this.servers.length - 1) {
      return null;
    }
    return this.servers[currentIndex + 1];
  }

  clearCache(): void {
    this.cachedBest = null;
    this.lastProbeTime = 0;
  }
}

// ============================================================================
// FILE: /webrtc-pro-kit/SignalingClient.ts
// ============================================================================

import { createClient, RealtimeChannel, SupabaseClient } from '@supabase/supabase-js';

export class SignalingClient {
  private client: SupabaseClient;
  private channel: RealtimeChannel | null = null;
  private roomId: string;
  private userId: string;
  private heartbeatInterval: NodeJS.Timeout | null = null;
  private signalHandlers: Set<(signal: SignalMessage) => void> = new Set();
  private presenceHandlers: Set<(event: PresenceEvent) => void> = new Set();
  private isConnected: boolean = false;

  constructor(supabaseUrl: string, supabaseKey: string, roomId: string, userId: string) {
    this.client = createClient(supabaseUrl, supabaseKey);
    this.roomId = roomId;
    this.userId = userId;
  }

  async connect(): Promise<void> {
    if (this.isConnected) return;

    this.channel = this.client.channel(`webrtc:${this.roomId}`);

    this.channel.on(
      'postgres_changes',
      {
        event: 'INSERT',
        schema: 'public',
        table: 'webrtc_signals',
        filter: `room_id=eq.${this.roomId}`,
      },
      (payload) => {
        const signal = this.parseSignal(payload.new);
        if (signal && signal.to === this.userId) {
          this.signalHandlers.forEach(handler => {
            try {
              handler(signal);
            } catch (error) {
              console.error('Signal handler error:', error);
            }
          });
        }
      }
    );

    this.channel.on(
      'postgres_changes',
      {
        event: '*',
        schema: 'public',
        table: 'webrtc_presence',
        filter: `room_id=eq.${this.roomId}`,
      },
      (payload) => {
        const event = this.parsePresenceEvent(payload);
        if (event && event.userId !== this.userId) {
          this.presenceHandlers.forEach(handler => {
            try {
              handler(event);
            } catch (error) {
              console.error('Presence handler error:', error);
            }
          });
        }
      }
    );

    await this.channel.subscribe();
    await this.notifyPresence('joined');
    this.startHeartbeat();
    this.isConnected = true;
  }

  async sendSignal(to: string, type: SignalMessage['type'], data: any): Promise<void> {
    try {
      await this.client.from('webrtc_signals').insert({
        room_id: this.roomId,
        from_user: this.userId,
        to_user: to,
        signal_type: type,
        signal_data: data,
        timestamp: new Date().toISOString(),
      });
    } catch (error) {
      console.error('Failed to send signal:', error);
      throw error;
    }
  }

  onSignal(handler: (signal: SignalMessage) => void): () => void {
    this.signalHandlers.add(handler);
    return () => this.signalHandlers.delete(handler);
  }

  onPresence(handler: (event: PresenceEvent) => void): () => void {
    this.presenceHandlers.add(handler);
    return () => this.presenceHandlers.delete(handler);
  }

  private async notifyPresence(status: 'joined' | 'left'): Promise<void> {
    try {
      if (status === 'joined') {
        await this.client.from('webrtc_presence').upsert({
          room_id: this.roomId,
          user_id: this.userId,
          status,
          last_heartbeat: new Date().toISOString(),
        });
      } else {
        await this.client
          .from('webrtc_presence')
          .update({ status, last_heartbeat: new Date().toISOString() })
          .eq('room_id', this.roomId)
          .eq('user_id', this.userId);
      }
    } catch (error) {
      console.error('Failed to notify presence:', error);
    }
  }

  private startHeartbeat(): void {
    // Clear any existing heartbeat
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
    }

    this.heartbeatInterval = setInterval(async () => {
      try {
        await this.client
          .from('webrtc_presence')
          .update({ last_heartbeat: new Date().toISOString() })
          .eq('room_id', this.roomId)
          .eq('user_id', this.userId);
      } catch (error) {
        console.error('Heartbeat failed:', error);
      }
    }, 30000);
  }

  private parseSignal(data: any): SignalMessage | null {
    try {
      return {
        type: data.signal_type,
        from: data.from_user,
        to: data.to_user,
        data: data.signal_data,
        timestamp: new Date(data.timestamp).getTime(),
      };
    } catch {
      return null;
    }
  }

  private parsePresenceEvent(payload: any): PresenceEvent | null {
    try {
      const data = payload.new || payload.old;
      return {
        userId: data.user_id,
        status: data.status,
        timestamp: Date.now(),
      };
    } catch {
      return null;
    }
  }

  async disconnect(): Promise<void> {
    if (!this.isConnected) return;

    // Clear heartbeat FIRST
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
    }

    await this.notifyPresence('left');

    if (this.channel) {
      await this.channel.unsubscribe();
      this.channel = null;
    }

    this.signalHandlers.clear();
    this.presenceHandlers.clear();
    this.isConnected = false;
  }
}

// ============================================================================
// FILE: /webrtc-pro-kit/AudioDucker.ts
// ============================================================================

export class AudioDucker {
  private context: AudioContext | null = null;
  private localGainNode: GainNode | null = null;
  private remoteGainNode: GainNode | null = null;
  private localSource: MediaStreamAudioSourceNode | null = null;
  private remoteSource: MediaStreamAudioSourceNode | null = null;
  private analyser: AnalyserNode | null = null;
  private destination: MediaStreamAudioDestinationNode | null = null;
  private isActive: boolean = false;
  private isDucked: boolean = false;
  private monitorInterval: number | null = null;

  async initialize(localStream: MediaStream, remoteStream?: MediaStream): Promise<MediaStream> {
    try {
      this.context = new AudioContext();
      this.destination = this.context.createMediaStreamDestination();
      
      // Local audio (user's mic)
      this.localGainNode = this.context.createGain();
      this.localSource = this.context.createMediaStreamSource(localStream);
      this.localSource.connect(this.localGainNode);
      this.localGainNode.connect(this.destination);
      
      // Remote audio (peer's audio) - for monitoring
      if (remoteStream) {
        this.remoteGainNode = this.context.createGain();
        this.remoteSource = this.context.createMediaStreamSource(remoteStream);
        this.analyser = this.context.createAnalyser();
        this.analyser.fftSize = 256;
        this.remoteSource.connect(this.analyser);
        this.remoteSource.connect(this.remoteGainNode);
        this.remoteGainNode.connect(this.destination);
        
        // Monitor remote audio and auto-duck local when remote is speaking
        this.startAutoD duck();
      }
      
      this.isActive = true;
      return this.destination.stream;
    } catch (error) {
      console.error('Audio ducker initialization failed:', error);
      return localStream;
    }
  }

  private startAutoDuck(): void {
    if (!this.analyser || !this.localGainNode) return;

    const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
    const threshold = 30; // Audio energy threshold

    this.monitorInterval = window.setInterval(() => {
      if (!this.analyser || !this.localGainNode) return;

      this.analyser.getByteFrequencyData(dataArray);
      const average = dataArray.reduce((a, b) => a + b) / dataArray.length;

      if (average > threshold && !this.isDucked) {
        // Remote is speaking, duck local audio
        this.localGainNode.gain.setValueAtTime(0.3, this.context!.currentTime);
        this.isDucked = true;
      } else if (average <= threshold && this.isDucked) {
        // Remote stopped speaking, restore local audio
        this.localGainNode.gain.setValueAtTime(1.0, this.context!.currentTime);
        this.isDucked = false;
      }
    }, 100);
  }

  manualDuck(level: number = 0.3): void {
    if (this.localGainNode && this.isActive) {
      this.localGainNode.gain.setValueAtTime(level, this.context!.currentTime);
    }
  }

  restore(): void {
    if (this.localGainNode && this.isActive) {
      this.localGainNode.gain.setValueAtTime(1.0, this.context!.currentTime);
    }
  }

  cleanup(): void {
    // Clear interval FIRST
    if (this.monitorInterval) {
      clearInterval(this.monitorInterval);
      this.monitorInterval = null;
    }

    if (this.localSource) {
      this.localSource.disconnect();
      this.localSource = null;
    }

    if (this.remoteSource) {
      this.remoteSource.disconnect();
      this.remoteSource = null;
    }
    
    if (this.localGainNode) {
      this.localGainNode.disconnect();
      this.localGainNode = null;
    }

    if (this.remoteGainNode) {
      this.remoteGainNode.disconnect();
      this.remoteGainNode = null;
    }

    if (this.analyser) {
      this.analyser.disconnect();
      this.analyser = null;
    }
    
    if (this.context && this.context.state !== 'closed') {
      this.context.close();
      this.context = null;
    }
    
    this.destination = null;
    this.isActive = false;
    this.isDucked = false;
  }
}

// ============================================================================
// FILE: /webrtc-pro-kit/StatsMonitor.ts
// ============================================================================

export class StatsMonitor {
  private pc: RTCPeerConnection;
  private intervalId: number | null = null;
  private lastStats: Map<string, any> = new Map();
  private onUpdate: (stats: StatsReport) => void;
  private lastTimestamp: number = 0;

  constructor(pc: RTCPeerConnection, onUpdate: (stats: StatsReport) => void) {
    this.pc = pc;
    this.onUpdate = onUpdate;
  }

  start(interval: number = STATS_INTERVAL): void {
    this.stop(); // Ensure no duplicate intervals
    
    this.intervalId = window.setInterval(async () => {
      // Check if peer connection is still valid
      if (!this.pc || this.pc.connectionState === 'closed' || this.pc.connectionState === 'failed') {
        this.stop();
        return;
      }

      try {
        const stats = await this.pc.getStats();
        const report = this.parseStats(stats);
        this.onUpdate(report);
      } catch (error) {
        console.error('Stats collection failed:', error);
        this.stop();
      }
    }, interval);
  }

  stop(): void {
    if (this.intervalId !== null) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
    this.lastStats.clear();
  }

  private parseStats(stats: RTCStatsReport): StatsReport {
    const now = Date.now();
    const timeDelta = this.lastTimestamp ? (now - this.lastTimestamp) / 1000 : 1;
    this.lastTimestamp = now;

    const report: StatsReport = {
      timestamp: now,
      bitrate: {
        video: { send: 0, receive: 0 },
        audio: { send: 0, receive: 0 },
      },
      packetLoss: 0,
      jitter: 0,
      rtt: 0,
      bandwidth: { available: 0, used: 0 },
    };

    stats.forEach((stat) => {
      if (stat.type === 'outbound-rtp') {
        const bytesSent = stat.bytesSent || 0;
        const lastBytes = this.lastStats.get(`${stat.id}-bytes`) || bytesSent;
        const bitrate = ((bytesSent - lastBytes) * 8) / timeDelta;
        this.lastStats.set(`${stat.id}-bytes`, bytesSent);

        if (stat.kind === 'video') {
          report.bitrate.video.send = bitrate;
          report.resolution = { width: stat.frameWidth || 0, height: stat.frameHeight || 0 };
          report.fps = stat.framesPerSecond || 0;
        } else if (stat.kind === 'audio') {
          report.bitrate.audio.send = bitrate;
        }
      }

      if (stat.type === 'inbound-rtp') {
        const bytesReceived = stat.bytesReceived || 0;
        const lastBytes = this.lastStats.get(`${stat.id}-bytes`) || bytesReceived;
        const bitrate = ((bytesReceived - lastBytes) * 8) / timeDelta;
        this.lastStats.set(`${stat.id}-bytes`, bytesReceived);

        if (stat.kind === 'video') {
          report.bitrate.video.receive = bitrate;
          report.codec = stat.mimeType || 'unknown';
        } else if (stat.kind === 'audio') {
          report.bitrate.audio.receive = bitrate;
        }

        report.packetLoss += stat.packetsLost || 0;
        report.jitter = Math.max(report.jitter, stat.jitter || 0);
      }

      if (stat.type === 'candidate-pair' && stat.state === 'succeeded') {
        report.rtt = (stat.currentRoundTripTime || 0) * 1000; // Convert to ms
        report.bandwidth.available = stat.availableOutgoingBitrate || 0;
      }
    });

    report.bandwidth.used =
      report.bitrate.video.send +
      report.bitrate.audio.send +
      report.bitrate.video.receive +
      report.bitrate.audio.receive;

    return report;
  }
}

// ============================================================================
// FILE: /webrtc-pro-kit/CallEngine.ts
// ============================================================================

export class CallEngine {
  private options: CallEngineOptions;
  private signaling: SignalingClient;
  private turnSelector: TurnSelector;
  private peerConnections: Map<string, RTCPeerConnection> = new Map();
  private iceCandidateQueues: Map<string, RTCIceCandidateInit[]> = new Map();
  private localStream: MediaStream | null = null;
  private screenStream: MediaStream | null = null;
  private audioDucker: AudioDucker | null = null;
  private statsMonitors: Map<string, StatsMonitor> = new Map();
  private eventHandlers: Map<CallEngineEvent, Set<Function>> = new Map();
  private reconnectAttempts: Map<string, number> = new Map();
  private bitrateAdaptationIntervals: Map<string, number> = new Map();
  private lastBitrateAdjustment: Map<string, number> = new Map();
  private isInitialized: boolean = false;
  private cleanupTasks: (() => void)[] = [];
  private negotiationStates: Map<string, { makingOffer: boolean; ignoreOffer: boolean }> = new Map();

  constructor(options: CallEngineOptions) {
    this.options = {
      videoQuality: 'medium',
      enableSVC: true,
      enableSimulcast: false,
      enableDTX: true,
      maxBandwidth: 5000,
      ...options,
    };

    this.signaling = new SignalingClient(
      options.supabaseUrl,
      options.supabaseKey,
      options.roomId,
      options.userId
    );

    this.turnSelector = new TurnSelector(options.turnServers);
  }

  async init(): Promise<void> {
    if (this.isInitialized) return;

    try {
      await this.signaling.connect();

      const unsubSignal = this.signaling.onSignal(this.handleSignal.bind(this));
      const unsubPresence = this.signaling.onPresence(this.handlePresence.bind(this));

      this.cleanupTasks.push(unsubSignal, unsubPresence);

      this.isInitialized = true;
      this.emit('engine:ready');
    } catch (error) {
      this.emit('error', { error: error as Error, context: 'initialization' });
      throw error;
    }
  }

  async startLocalMedia(constraints: MediaStreamConstraints): Promise<MediaStream> {
    try {
      if (!validateMediaConstraints(constraints)) {
        throw new Error('Invalid media constraints');
      }

      const preset = VIDEO_QUALITY_PRESETS[this.options.videoQuality!];
      
      if (constraints.video && typeof constraints.video === 'object') {
        constraints.video = {
          ...constraints.video,
          width: { ideal: preset.width },
          height: { ideal: preset.height },
          frameRate: { ideal: preset.frameRate },
        };
      }

      // Enable DTX for audio
      if (constraints.audio && typeof constraints.audio === 'object' && this.options.enableDTX) {
        constraints.audio = {
          ...constraints.audio,
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
        };
      }

      this.localStream = await navigator.mediaDevices.getUserMedia(constraints);

      // Add tracks to existing peer connections with proper encoding
      this.peerConnections.forEach((pc, peerId) => {
        this.localStream!.getTracks().forEach((track) => {
          const sender = pc.addTrack(track, this.localStream!);
          this.configureTrackEncoding(sender, track.kind as 'audio' | 'video');
        });
      });

      return this.localStream;
    } catch (error) {
      this.emit('error', { error: error as Error, context: 'getUserMedia' });
      throw error;
    }
  }

  private configureTrackEncoding(sender: RTCRtpSender, kind: 'audio' | 'video'): void {
    const params = sender.getParameters();
    
    if (!params.encodings || params.encodings.length === 0) {
      params.encodings = [{}];
    }

    if (kind === 'video') {
      const preset = VIDEO_QUALITY_PRESETS[this.options.videoQuality!];
      
      if (this.options.enableSimulcast && params.encodings.length < 3) {
        // Configure simulcast layers for adaptive streaming
        params.encodings = [
          { 
            rid: 'h', 
            maxBitrate: preset.maxBitrate,
            scaleResolutionDownBy: 1.0 
          },
          { 
            rid: 'm', 
            maxBitrate: preset.maxBitrate * 0.5,
            scaleResolutionDownBy: 2.0 
          },
          { 
            rid: 'l', 
            maxBitrate: preset.maxBitrate * 0.2,
            scaleResolutionDownBy: 4.0 
          },
        ];
      } else if (this.options.enableSVC) {
        // SVC (Scalable Video Coding) for VP9/AV1
        params.encodings[0] = {
          maxBitrate: preset.maxBitrate,
          scalabilityMode: 'L3T3', // 3 spatial, 3 temporal layers
        };
      } else {
        // Single layer with adaptive bitrate
        params.encodings[0] = {
          maxBitrate: preset.maxBitrate,
          minBitrate: preset.minBitrate,
        };
      }
    } else if (kind === 'audio') {
      // Enable DTX (Discontinuous Transmission) for audio
      if (this.options.enableDTX) {
        params.encodings[0] = {
          ...params.encodings[0],
          maxBitrate: 64000, // 64 kbps max for audio
        };
      }
    }

    sender.setParameters(params).catch(error => {
      console.error('Failed to configure encoding:', error);
    });
  }

  async startScreenShare(options?: DisplayMediaStreamOptions): Promise<MediaStream> {
    try {
      const constraints: DisplayMediaStreamOptions = {
        video: {
          cursor: 'always',
          displaySurface: 'monitor',
          width: { ideal: 1920 },
          height: { ideal: 1080 },
          frameRate: { ideal: 30 },
          ...options?.video,
        } as MediaTrackConstraints,
        audio: options?.audio || false,
        ...options,
      };

      this.screenStream = await navigator.mediaDevices.getDisplayMedia(constraints);

      // Handle screen share stop
      this.screenStream.getVideoTracks()[0].addEventListener('ended', () => {
        this.stopScreenShare();
      });

      // Add screen tracks to peer connections
      this.peerConnections.forEach(async (pc, peerId) => {
        this.screenStream!.getTracks().forEach((track) => {
          const sender = pc.addTrack(track, this.screenStream!);
          
          // Screen share always gets max quality
          if (track.kind === 'video') {
            const params = sender.getParameters();
            if (!params.encodings || params.encodings.length === 0) {
              params.encodings = [{}];
            }
            params.encodings[0].maxBitrate = 3000000; // 3 Mbps for screen
            sender.setParameters(params);
          }
        });
        
        // Trigger renegotiation
        await this.triggerNegotiation(peerId);
      });

      // Duck local mic audio when screen sharing with audio
      if (options?.audio && this.audioDucker) {
        this.audioDucker.manualDuck(0.3);
      }

      return this.screenStream;
    } catch (error) {
      this.emit('error', { error: error as Error, context: 'getDisplayMedia' });
      throw error;
    }
  }

  stopScreenShare(): void {
    if (!this.screenStream) return;

    // Remove screen tracks from peer connections
    this.peerConnections.forEach((pc) => {
      const senders = pc.getSenders();
      senders.forEach((sender) => {
        if (this.screenStream?.getTracks().includes(sender.track!)) {
          pc.removeTrack(sender);
        }
      });
    });

    cleanupMediaStream(this.screenStream);
    this.screenStream = null;

    // Restore audio
    if (this.audioDucker) {
      this.audioDucker.restore();
    }
  }

  async toggleMute(kind: 'audio' | 'video', mute: boolean): Promise<void> {
    const stream = this.localStream;
    if (!stream) return;

    const tracks = kind === 'audio' ? stream.getAudioTracks() : stream.getVideoTracks();
    tracks.forEach((track) => {
      track.enabled = !mute;
    });
  }

  async endCall(): Promise<void> {
    const peerIds = Array.from(this.peerConnections.keys());
    await Promise.all(
      peerIds.map((peerId) =>
        this.signaling.sendSignal(peerId, 'bye', {}).catch(() => {})
      )
    );

    await this.cleanup();
    this.emit('engine:disconnected');
  }

  on<K extends CallEngineEvent>(
    event: K,
    handler: (data: CallEngineEventMap[K]) => void
  ): () => void {
    if (!this.eventHandlers.has(event)) {
      this.eventHandlers.set(event, new Set());
    }
    this.eventHandlers.get(event)!.add(handler);

    return () => {
      this.eventHandlers.get(event)?.delete(handler);
    };
  }

  private emit<K extends CallEngineEvent>(event: K, data?: CallEngineEventMap[K]): void {
    this.eventHandlers.get(event)?.forEach((handler) => {
      try {
        handler(data);
      } catch (error) {
        console.error(`Error in event handler for ${event}:`, error);
      }
    });
  }

  private async handleSignal(signal: SignalMessage): Promise<void> {
    try {
      switch (signal.type) {
        case 'offer':
          await this.handleOffer(signal);
          break;
        case 'answer':
          await this.handleAnswer(signal);
          break;
        case 'ice-candidate':
          await this.handleIceCandidate(signal);
          break;
        case 'renegotiate':
          await this.handleOffer(signal);
          break;
        case 'bye':
          await this.handleBye(signal);
          break;
      }
    } catch (error) {
      this.emit('error', { error: error as Error, context: `handleSignal:${signal.type}` });
    }
  }

  private async handlePresence(event: PresenceEvent): Promise<void> {
    if (event.status === 'joined') {
      this.emit('peer:joined', { userId: event.userId });
      await this.createPeerConnection(event.userId, true);
    } else if (event.status === 'left') {
      this.emit('peer:left', { userId: event.userId });
      await this.closePeerConnection(event.userId);
    }
  }

  private async createPeerConnection(peerId: string, polite: boolean): Promise<RTCPeerConnection> {
    if (this.peerConnections.has(peerId)) {
      return this.peerConnections.get(peerId)!;
    }

    const turnServer = await this.turnSelector.selectOptimalServer();

    const config: RTCConfiguration = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        {
          urls: turnServer.urls,
          username: turnServer.username,
          credential: turnServer.credential,
        },
      ],
      iceTransportPolicy: 'all',
      bundlePolicy: 'max-bundle',
      rtcpMuxPolicy: 'require',
    };

    const pc = new RTCPeerConnection(config);
    this.peerConnections.set(peerId, pc);
    this.iceCandidateQueues.set(peerId, []);
    this.negotiationStates.set(peerId, { makingOffer: false, ignoreOffer: false });

    // Add local tracks
    if (this.localStream) {
      this.localStream.getTracks().forEach((track) => {
        const sender = pc.addTrack(track, this.localStream!);
        this.configureTrackEncoding(sender, track.kind as 'audio' | 'video');
      });
    }

    this.setupPeerConnectionHandlers(pc, peerId, polite);

    // Start stats monitor
    const monitor = new StatsMonitor(pc, (stats) => {
      this.emit('stats:update', stats);
      this.adaptiveBitrateControl(pc, peerId, stats);
    });
    monitor.start();
    this.statsMonitors.set(peerId, monitor);

    // Start adaptive bitrate control
    this.startBitrateAdaptation(peerId);

    return pc;
  }

  private setupPeerConnectionHandlers(pc: RTCPeerConnection, peerId: string, polite: boolean): void {
    const state = this.negotiationStates.get(peerId)!;

    // ICE candidate handler
    pc.onicecandidate = ({ candidate }) => {
      if (candidate) {
        this.signaling.sendSignal(peerId, 'ice-candidate', candidate.toJSON()).catch((error) => {
          this.emit('error', { error, context: 'sendIceCandidate' });
        });
      }
    };

    // Track handler
    pc.ontrack = ({ track, streams }) => {
      this.emit('track:added', { track, stream: streams[0], userId: peerId });

      track.onended = () => {
        this.emit('track:removed', { trackId: track.id, userId: peerId });
      };
    };

    // Perfect negotiation pattern
    pc.onnegotiationneeded = async () => {
      try {
        state.makingOffer = true;
        await pc.setLocalDescription();
        await this.signaling.sendSignal(peerId, 'offer', pc.localDescription);
      } catch (error) {
        this.emit('error', { error: error as Error, context: 'negotiation' });
      } finally {
        state.makingOffer = false;
      }
    };

    // Connection state handler
    pc.onconnectionstatechange = () => {
      if (pc.connectionState === 'failed') {
        this.handleConnectionFailure(peerId);
      } else if (pc.connectionState === 'disconnected') {
        this.scheduleReconnect(peerId);
      } else if (pc.connectionState === 'connected') {
        this.reconnectAttempts.delete(peerId);
      }
    };

    // ICE connection state handler
    pc.oniceconnectionstatechange = () => {
      if (pc.iceConnectionState === 'failed') {
        this.handleIceFailure(peerId);
      }
    };
  }

  private async handleOffer(signal: SignalMessage): Promise<void> {
    const peerId = signal.from;
    let pc = this.peerConnections.get(peerId);

    if (!pc) {
      pc = await this.createPeerConnection(peerId, false);
    }

    const state = this.negotiationStates.get(peerId)!;
    const offerCollision = 
      (signal.type === 'offer') &&
      (state.makingOffer || pc.signalingState !== 'stable');

    state.ignoreOffer = !this.isPolite(peerId) && offerCollision;
    
    if (state.ignoreOffer) {
      return;
    }

    await pc.setRemoteDescription(new RTCSessionDescription(signal.data));

    // Process queued ICE candidates
    const queue = this.iceCandidateQueues.get(peerId) || [];
    while (queue.length > 0) {
      const candidate = queue.shift()!;
      try {
        await pc.addIceCandidate(candidate);
      } catch (error) {
        console.error('Failed to add queued ICE candidate:', error);
      }
    }

    if (signal.type === 'offer') {
      await pc.setLocalDescription();
      await this.signaling.sendSignal(peerId, 'answer', pc.localDescription);
    }
  }

  private async handleAnswer(signal: SignalMessage): Promise<void> {
    const pc = this.peerConnections.get(signal.from);
    if (!pc) return;

    try {
      await pc.setRemoteDescription(new RTCSessionDescription(signal.data));

      // Process queued ICE candidates
      const queue = this.iceCandidateQueues.get(signal.from) || [];
      while (queue.length > 0) {
        const candidate = queue.shift()!;
        await pc.addIceCandidate(candidate);
      }
    } catch (error) {
      this.emit('error', { error: error as Error, context: 'handleAnswer' });
    }
  }

  private async handleIceCandidate(signal: SignalMessage): Promise<void> {
    const pc = this.peerConnections.get(signal.from);
    if (!pc) return;

    try {
      // Queue candidates if remote description not set
      if (!pc.remoteDescription || !pc.remoteDescription.type) {
        this.iceCandidateQueues.get(signal.from)?.push(signal.data);
        return;
      }

      await pc.addIceCandidate(new RTCIceCandidate(signal.data));
    } catch (error) {
      if (pc.remoteDescription) {
        this.emit('error', { error: error as Error, context: 'addIceCandidate' });
      }
    }
  }

  private async handleBye(signal: SignalMessage): Promise<void> {
    await this.closePeerConnection(signal.from);
    this.emit('peer:left', { userId: signal.from });
  }

  private async triggerNegotiation(peerId: string): Promise<void> {
    const pc = this.peerConnections.get(peerId);
    if (!pc) return;

    try {
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await this.signaling.sendSignal(peerId, 'offer', pc.localDescription);
    } catch (error) {
      this.emit('error', { error: error as Error, context: 'triggerNegotiation' });
    }
  }

  private isPolite(peerId: string): boolean {
    // Determine politeness based on user ID comparison
    return this.options.userId < peerId;
  }

  private startBitrateAdaptation(peerId: string): void {
    // Clear any existing interval
    const existingInterval = this.bitrateAdaptationIntervals.get(peerId);
    if (existingInterval) {
      clearInterval(existingInterval);
    }

    const interval = window.setInterval(() => {
      const pc = this.peerConnections.get(peerId);
      if (!pc || pc.connectionState !== 'connected') {
        this.stopBitrateAdaptation(peerId);
        return;
      }
    }, BITRATE_ADAPTATION_INTERVAL);

    this.bitrateAdaptationIntervals.set(peerId, interval);
  }

  private stopBitrateAdaptation(peerId: string): void {
    const interval = this.bitrateAdaptationIntervals.get(peerId);
    if (interval) {
      clearInterval(interval);
      this.bitrateAdaptationIntervals.delete(peerId);
    }
    this.lastBitrateAdjustment.delete(peerId);
  }

  private adaptiveBitrateControl(pc: RTCPeerConnection, peerId: string, stats: StatsReport): void {
    const sender = pc.getSenders().find((s) => s.track?.kind === 'video');
    if (!sender || !sender.track) return;

    const params = sender.getParameters();
    if (!params.encodings || params.encodings.length === 0) return;

    const preset = VIDEO_QUALITY_PRESETS[this.options.videoQuality!];
    const now = Date.now();
    const lastAdjustment = this.lastBitrateAdjustment.get(peerId) || 0;

    // Rate limit adjustments (every 2 seconds minimum)
    if (now - lastAdjustment < BITRATE_ADAPTATION_INTERVAL) {
      return;
    }

    const currentBitrate = stats.bitrate.video.send;
    const availableBandwidth = stats.bandwidth.available * BANDWIDTH_SAFETY_MARGIN;
    const packetLossRate = stats.packetLoss / (stats.packetLoss + 100); // Approximate
    const rtt = stats.rtt;

    let targetBitrate = currentBitrate;

    // Critical conditions - reduce aggressively
    if (packetLossRate > PACKET_LOSS_THRESHOLD) {
      targetBitrate = currentBitrate * 0.7;
      this.emit('bandwidth:warning', { 
        available: availableBandwidth, 
        required: currentBitrate 
      });
    } 
    // High RTT - reduce moderately
    else if (rtt > RTT_THRESHOLD) {
      targetBitrate = currentBitrate * 0.85;
    }
    // Good conditions - increase gradually
    else if (packetLossRate < 0.01 && rtt < 150 && availableBandwidth > currentBitrate * 1.5) {
      targetBitrate = Math.min(currentBitrate * 1.1, preset.maxBitrate);
    }
    // Bandwidth constrained - match available
    else if (availableBandwidth < currentBitrate) {
      targetBitrate = availableBandwidth * 0.85;
    }

    // Clamp to preset bounds
    targetBitrate = Math.max(
      preset.minBitrate,
      Math.min(targetBitrate, preset.maxBitrate)
    );

    // Apply with hysteresis (only if change > 10%)
    const changeRatio = Math.abs(targetBitrate - currentBitrate) / currentBitrate;
    if (changeRatio > 0.1) {
      params.encodings.forEach(encoding => {
        encoding.maxBitrate = Math.floor(targetBitrate);
      });

      sender.setParameters(params).catch((error) => {
        console.error('Failed to adapt bitrate:', error);
      });

      this.lastBitrateAdjustment.set(peerId, now);
    }
  }

  private handleConnectionFailure(peerId: string): void {
    this.emit('error', {
      error: new Error(`Connection failed for peer ${peerId}`),
      context: 'connectionState',
    });
    this.scheduleReconnect(peerId);
  }

  private handleIceFailure(peerId: string): void {
    this.emit('error', {
      error: new Error(`ICE connection failed for peer ${peerId}`),
      context: 'iceConnectionState',
    });
    
    const pc = this.peerConnections.get(peerId);
    if (pc) {
      const currentConfig = pc.getConfiguration();
      const currentTurn = currentConfig.iceServers?.find((s) => 
        s.urls.toString().includes('turn')
      ) as TurnServer;
      
      if (currentTurn) {
        const nextTurn = this.turnSelector.getNextFallback(currentTurn);
        if (nextTurn) {
          this.restartIceWithNewTurn(peerId, nextTurn);
          return;
        }
      }
    }

    this.scheduleReconnect(peerId);
  }

  private scheduleReconnect(peerId: string): void {
    const attempts = this.reconnectAttempts.get(peerId) || 0;

    if (attempts >= RECONNECT_MAX_ATTEMPTS) {
      this.emit('reconnect:failed');
      this.closePeerConnection(peerId);
      return;
    }

    this.reconnectAttempts.set(peerId, attempts + 1);
    this.emit('reconnect:attempt', { attempt: attempts + 1 });

    const delay = exponentialBackoff(attempts, RECONNECT_BASE_DELAY, RECONNECT_MAX_DELAY);

    setTimeout(async () => {
      const pc = this.peerConnections.get(peerId);
      if (pc && pc.connectionState !== 'connected') {
        await this.restartIce(peerId);
      }
    }, delay);
  }

  private async restartIce(peerId: string): Promise<void> {
    const pc = this.peerConnections.get(peerId);
    if (!pc) return;

    try {
      const offer = await pc.createOffer({ iceRestart: true });
      await pc.setLocalDescription(offer);
      await this.signaling.sendSignal(peerId, 'offer', offer);
    } catch (error) {
      this.emit('error', { error: error as Error, context: 'iceRestart' });
    }
  }

  private async restartIceWithNewTurn(peerId: string, turnServer: TurnServer): Promise<void> {
    const pc = this.peerConnections.get(peerId);
    if (!pc) return;

    const config = pc.getConfiguration();
    config.iceServers = [
      { urls: 'stun:stun.l.google.com:19302' },
      {
        urls: turnServer.urls,
        username: turnServer.username,
        credential: turnServer.credential,
      },
    ];

    pc.setConfiguration(config);
    await this.restartIce(peerId);
  }

  private async closePeerConnection(peerId: string): Promise<void> {
    // Stop stats monitor first
    const monitor = this.statsMonitors.get(peerId);
    if (monitor) {
      monitor.stop();
      this.statsMonitors.delete(peerId);
    }

    // Stop bitrate adaptation
    this.stopBitrateAdaptation(peerId);

    // Clear ICE candidate queue
    this.iceCandidateQueues.delete(peerId);

    // Clear negotiation state
    this.negotiationStates.delete(peerId);

    // Cleanup peer connection
    const pc = this.peerConnections.get(peerId);
    if (pc) {
      cleanupPeerConnection(pc);
      this.peerConnections.delete(peerId);
    }

    this.reconnectAttempts.delete(peerId);
  }

  private async cleanup(): Promise<void> {
    // Stop all bitrate adaptation intervals
    this.bitrateAdaptationIntervals.forEach((interval) => {
      clearInterval(interval);
    });
    this.bitrateAdaptationIntervals.clear();

    // Stop all stats monitors
    this.statsMonitors.forEach((monitor) => monitor.stop());
    this.statsMonitors.clear();

    // Close all peer connections
    const peerIds = Array.from(this.peerConnections.keys());
    await Promise.all(peerIds.map((peerId) => this.closePeerConnection(peerId)));

    // Cleanup local media
    if (this.localStream) {
      cleanupMediaStream(this.localStream);
      this.localStream = null;
    }

    // Cleanup screen share
    if (this.screenStream) {
      cleanupMediaStream(this.screenStream);
      this.screenStream = null;
    }

    // Cleanup audio ducker
    if (this.audioDucker) {
      this.audioDucker.cleanup();
      this.audioDucker = null;
    }

    // Disconnect signaling
    await this.signaling.disconnect();

    // Execute cleanup tasks
    this.cleanupTasks.forEach((task) => {
      try {
        task();
      } catch (error) {
        console.error('Cleanup task failed:', error);
      }
    });
    this.cleanupTasks = [];

    // Clear all state
    this.eventHandlers.clear();
    this.reconnectAttempts.clear();
    this.iceCandidateQueues.clear();
    this.negotiationStates.clear();
    this.lastBitrateAdjustment.clear();

    this.isInitialized = false;
  }
}

// ============================================================================
// FILE: /webrtc-pro-kit/index.ts
// ============================================================================

export { CallEngine } from './CallEngine';
export { SignalingClient } from './SignalingClient';
export { TurnSelector } from './TurnSelector';
export { AudioDucker } from './AudioDucker';
export { StatsMonitor } from './StatsMonitor';

export type {
  CallEngineOptions,
  CallEngineEvent,
  CallEngineEventMap,
  VideoQuality,
  VideoQualityPreset,
  TurnServer,
  SignalMessage,
  PresenceEvent,
  StatsReport,
} from './types';

export {
  VIDEO_QUALITY_PRESETS,
  ICE_GATHERING_TIMEOUT,
  RECONNECT_MAX_ATTEMPTS,
  RECONNECT_BASE_DELAY,
  RECONNECT_MAX_DELAY,
  STATS_INTERVAL,
  TURN_PROBE_TIMEOUT,
  NEGOTIATION_TIMEOUT,
  BITRATE_ADAPTATION_INTERVAL,
  PACKET_LOSS_THRESHOLD,
  RTT_THRESHOLD,
  BANDWIDTH_SAFETY_MARGIN,
} from './constants';

export {
  exponentialBackoff,
  validateMediaConstraints,
  probeServerLatency,
  cleanupMediaStream,
  cleanupPeerConnection,
} from './utils';